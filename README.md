# PFG-Kata-Examples

Example katas and example solutions &amp; discussions for Principal Financial Group interns

> [!NOTE]  
> A Kata is an exercise that can be repeated many times. Each kata is meant to be something you can continuously repeat and improve.

## Navigating

Each folder in this project is an example problem that has been given to interns during the Principal intern interview process. Each is meant to not only allow potential interns to show
their technical ability, but also to see how they think through the problem and collaborate with interviewers. 

## General Kata Strategy

Katas are meant to be collaborative and fun, but can be hard at first, especially when interview nerves are a factor. Practicing speaking aloud and working through a problem in a methodical, robust way can be extremely helpful. If you have someone
that can be a rubber-duck or even someone that knows enough to ask questions while doing these examples it may help when it comes to the actual interview.

*Do not be afraid to use a cheat-sheet or Google* - It is nice to choose a language you are comfortable with but searching the internet for syntax questions is something every engineer does every day. Just avoid copying any large chunk of code from StackOverflow or similar sites

*Vocalize as much as possible* - Interviewers want to know what you are thinking, and may chime in to confirm/reject certain ideas/assumptions. Make sure you are comfortable talking through a problem!

*Collaborate* - Katas are meant to be a team effort! Bounce ideas off your interviewers and involve them in decisions. They are there to help and it's way more fun to code together than sit there and have 2 people watch you code.

### Time-Limit

The time limit for these is purposely short. You shouldn't expect to "finish" the kata, instead focus on organizing your thoughts a clear manner and ensure any code you do write is robust.

* Start by talking through the problem with the interviewer, starting the coding process too early forces you to do design and coding at the same time, which can result in losing track of what you are doing, especially in an interview atmosphere
* Consider doing a more naive solution than could be designed and coming back to improve it later
* Once you are ready to start coding, set up the skeleton of what you are coding. Then you can focus on one smaller coding problem at a time, allowing you to code without getting cut off
  * How are you going to run your solution?
  * What sort of objects and methods will you need? DON'T WORRY about filling implementation details in, you can always hard code things or write comments & pseudocode in the interest of time
  * What would an ideal input/output for the problem be? You typically don't need to start with the whole data set given in the problem. Sometimes hard coding a smaller input can help ensure less confusion

### Ambiguity

These Katas tend to be fairly open-ended on purpose, interviewees are expected to either vocalize their assumptions to ensure it makes sense or use the interviewers as product owners to narrow down the focus of the problem and resolve edge cases.

* Talk through any obvious ambiguities, especially ambiguous words like "best". If they are asking for the best system, ensure you know what that means in the context of the problem (fastest? most people happy?)
* Talk through edge cases, often you can make assumptions that eliminate these but make sure you ask the interviewer if it's ok!
* Talk through error scenarios, where are the most likely places where things could go wrong?
* Discuss how such a system might practically work in the real world (this can help you make good assumptions)
* Posit a naive solution, discuss with the interviewer what it lacks that they are looking for

### Design

Try to ensure you do some work to architect a good design at the beginning of the technical interview. 

* Consider drawing/diagramming out the problem in a good visual editor
* Consider taking notes on assumptions/requirements
* If you have the capacity, consider discussing the pros/cons of potential technologies (like what language fits the problem best, what infrastructure it might run on) (ADVANCED)
